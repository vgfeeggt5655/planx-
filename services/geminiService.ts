import { GoogleGenAI, Type } from "@google/genai";
import { MCQ, Flashcard } from '../types';

// The 'if (!process.env.API_KEY)' check was removed as it crashed the app in browser environments.
// Optional chaining is used here to safely access `process.env.API_KEY`. If it doesn't exist,
// an empty string is passed to the constructor. This prevents the app from crashing on load.
// API calls will fail with an invalid key, but this is handled by the try/catch blocks below,
// allowing the rest of the application to remain functional.
const ai = new GoogleGenAI({ apiKey: process?.env?.API_KEY || "" });

/**
 * Resizes a base64 image string to a smaller size to reduce its length.
 * @param base64Str The original base64 data URI.
 * @param maxWidth The maximum width of the resized image.
 * @param maxHeight The maximum height of the resized image.
 * @returns A promise that resolves with the resized base64 data URI.
 */
const resizeImage = (base64Str: string, maxWidth: number, maxHeight: number): Promise<string> => {
    return new Promise((resolve) => {
        const img = new Image();
        img.src = base64Str;
        img.onload = () => {
            const canvas = document.createElement('canvas');
            let { width, height } = img;

            if (width > height) {
                if (width > maxWidth) {
                    height *= maxWidth / width;
                    width = maxWidth;
                }
            } else {
                if (height > maxHeight) {
                    width *= maxHeight / height;
                    height = maxHeight;
                }
            }
            canvas.width = width;
            canvas.height = height;
            const ctx = canvas.getContext('2d');
            if (!ctx) {
                // Fallback to original if canvas context is not available
                resolve(base64Str);
                return;
            }
            ctx.drawImage(img, 0, 0, width, height);
            // Get data URL with JPEG compression to further reduce size
            resolve(canvas.toDataURL('image/jpeg', 0.8)); // 80% quality
        };
        img.onerror = () => {
            // Fallback to original if the image fails to load
            resolve(base64Str);
        };
    });
};


export const generateImage = async (prompt: string): Promise<string> => {
  try {
    const response = await ai.models.generateImages({
        model: 'imagen-3.0-generate-002',
        prompt: `A high-quality, visually appealing educational illustration for the following topic: "${prompt}". The style should be modern, clean, and engaging for learners, suitable for a course thumbnail.`,
        config: {
          numberOfImages: 1,
          outputMimeType: 'image/jpeg',
          aspectRatio: '16:9',
        },
    });

    if (response.generatedImages && response.generatedImages.length > 0) {
      const base64ImageBytes: string = response.generatedImages[0].image.imageBytes;
      const originalDataUrl = `data:image/jpeg;base64,${base64ImageBytes}`;
      
      // Resize to a max width of 800px to reduce the base64 string length significantly
      const resizedDataUrl = await resizeImage(originalDataUrl, 800, 450);
      return resizedDataUrl;

    } else {
      throw new Error("No image was generated by the API.");
    }
  } catch (error) {
    console.error("Error generating image with Gemini API:", error);
    // Fallback to a placeholder image on error
    return `https://picsum.photos/seed/${encodeURIComponent(prompt)}/1280/720`;
  }
};

export const generateMCQs = async (pdfText: string): Promise<MCQ[]> => {
  try {
    // Truncate text to avoid exceeding token limits, focusing on the beginning which often has objectives.
    const truncatedText = pdfText.length > 20000 ? pdfText.substring(0, 20000) : pdfText;
    const prompt = `Based on the following text from a medical lecture PDF: "${truncatedText}". Make a quiz of 20 MCQ questions. Each question must have 4 options and one correct answer. Focus on the key points, especially anything that looks like it's from an "objectives" or "summary" slide.`;
    
    const response = await ai.models.generateContent({
      model: "gemini-2.5-flash",
      contents: prompt,
      config: {
        responseMimeType: "application/json",
        responseSchema: {
          type: Type.ARRAY,
          items: {
            type: Type.OBJECT,
            properties: {
              question: { type: Type.STRING },
              options: {
                type: Type.ARRAY,
                items: { type: Type.STRING }
              },
              correctAnswer: { type: Type.STRING }
            },
            required: ["question", "options", "correctAnswer"]
          }
        }
      }
    });

    const jsonText = response.text.trim();
    const mcqs = JSON.parse(jsonText);

    if (!Array.isArray(mcqs)) {
      throw new Error("API did not return a valid array of MCQs.");
    }

    // Additional validation
    return mcqs.filter(mcq => 
        mcq.question && 
        Array.isArray(mcq.options) && 
        mcq.options.length > 0 && 
        mcq.correctAnswer &&
        mcq.options.includes(mcq.correctAnswer)
    );

  } catch (error) {
    console.error("Error generating MCQs with Gemini API:", error);
    throw new Error("Failed to generate the quiz. The AI might be busy, please try again later.");
  }
};

export const generateFlashcards = async (pdfText: string): Promise<Flashcard[]> => {
  try {
    const truncatedText = pdfText.length > 20000 ? pdfText.substring(0, 20000) : pdfText;
    const prompt = `Based on the following text from a medical lecture PDF, create a set of flashcards. Each flashcard should have a "front" (a question or a term) and a "back" (the answer or definition). Focus on key concepts, definitions, and important facts. Create around 15-20 flashcards. Text: "${truncatedText}"`;
    
    const response = await ai.models.generateContent({
      model: "gemini-2.5-flash",
      contents: prompt,
      config: {
        responseMimeType: "application/json",
        responseSchema: {
          type: Type.ARRAY,
          items: {
            type: Type.OBJECT,
            properties: {
              front: { type: Type.STRING, description: "The question or term on the front of the card." },
              back: { type: Type.STRING, description: "The answer or definition on the back of the card." }
            },
            required: ["front", "back"]
          }
        }
      }
    });

    const jsonText = response.text.trim();
    const flashcards = JSON.parse(jsonText);

    if (!Array.isArray(flashcards)) {
      throw new Error("API did not return a valid array of flashcards.");
    }
    
    // Basic validation
    return flashcards.filter(fc => fc.front && fc.back);

  } catch (error) {
    console.error("Error generating flashcards with Gemini API:", error);
    throw new Error("Failed to generate flashcards. The AI might be busy, please try again later.");
  }
};